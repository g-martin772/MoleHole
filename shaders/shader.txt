#version 330 core

const float PI = 3.14159265359;
const float EPSILON = 0.0001;
const float INFINITY = 1000000.0;

out vec4 fragColor;

uniform vec2 resolution; // viewport resolution in pixels
uniform float mouseX;
uniform float mouseY;

uniform float time; // time elapsed in seconds
uniform samplerCube galaxy;
uniform sampler2D colorMap;

// Camera uniforms - replacing hardcoded camera logic
uniform vec3 cameraPos;
uniform vec3 cameraFront;
uniform vec3 cameraUp;
uniform vec3 cameraRight;
uniform float cameraFov;
uniform float cameraAspect;

// Legacy uniforms (kept for compatibility)
uniform float frontView = 0.0;
uniform float topView = 0.0;
uniform float cameraRoll = 0.0;

uniform float gravatationalLensing = 1.0;
uniform float renderBlackHole = 1.0;
uniform float mouseControl = 0.0;
uniform float fovScale = 1.0;

uniform float adiskEnabled = 1.0;
uniform float adiskParticle = 1.0;
uniform float adiskHeight = 0.2;
uniform float adiskLit = 0.5;
uniform float adiskDensityV = 1.0;
uniform float adiskDensityH = 1.0;
uniform float adiskNoiseScale = 1.0;
uniform float adiskNoiseLOD = 5.0;
uniform float adiskSpeed = 0.5;

struct Ring {
    vec3 center;
    vec3 normal;
    float innerRadius;
    float outerRadius;
    float rotateSpeed;
};

///----
/// Simplex 3D Noise
/// by Ian McEwan, Ashima Arts
vec4 permute(vec4 x) { return mod(((x * 34.0) + 1.0) * x, 289.0); }
vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

float snoise(vec3 v) {
    const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);
    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);

    // First corner
    vec3 i = floor(v + dot(v, C.yyy));
    vec3 x0 = v - i + dot(i, C.xxx);

    // Other corners
    vec3 g = step(x0.yzx, x0.xyz);
    vec3 l = 1.0 - g;
    vec3 i1 = min(g.xyz, l.zxy);
    vec3 i2 = max(g.xyz, l.zxy);

    //  x0 = x0 - 0. + 0.0 * C
    vec3 x1 = x0 - i1 + 1.0 * C.xxx;
    vec3 x2 = x0 - i2 + 2.0 * C.xxx;
    vec3 x3 = x0 - 1. + 3.0 * C.xxx;

    // Permutations
    i = mod(i, 289.0);
    vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y +
    vec4(0.0, i1.y, i2.y, 1.0)) +
    i.x + vec4(0.0, i1.x, i2.x, 1.0));

    // Gradients
    // ( N*N points uniformly over a square, mapped onto an octahedron.)
    float n_ = 1.0 / 7.0; // N=7
    vec3 ns = n_ * D.wyz - D.xzx;

    vec4 j = p - 49.0 * floor(p * ns.z * ns.z); //  mod(p,N*N)

    vec4 x_ = floor(j * ns.z);
    vec4 y_ = floor(j - 7.0 * x_); // mod(j,N)

    vec4 x = x_ * ns.x + ns.yyyy;
    vec4 y = y_ * ns.x + ns.yyyy;
    vec4 h = 1.0 - abs(x) - abs(y);

    vec4 b0 = vec4(x.xy, y.xy);
    vec4 b1 = vec4(x.zw, y.zw);

    vec4 s0 = floor(b0) * 2.0 + 1.0;
    vec4 s1 = floor(b1) * 2.0 + 1.0;
    vec4 sh = -step(h, vec4(0.0));

    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;

    vec3 p0 = vec3(a0.xy, h.x);
    vec3 p1 = vec3(a0.zw, h.y);
    vec3 p2 = vec3(a1.xy, h.z);
    vec3 p3 = vec3(a1.zw, h.w);

    // Normalise gradients
    vec4 norm =
    taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
    p0 *= norm.x;
    p1 *= norm.y;
    p2 *= norm.z;
    p3 *= norm.w;

    // Mix final noise value
    vec4 m =
    max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);
    m = m * m;
    return 42.0 *
    dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));
}
///----

float ringDistance(vec3 rayOrigin, vec3 rayDir, Ring ring) {
    float denominator = dot(rayDir, ring.normal);
    float constant = -dot(ring.center, ring.normal);
    if (abs(denominator) < EPSILON) {
        return -1.0;
    } else {
        float t = -(dot(rayOrigin, ring.normal) + constant) / denominator;
        if (t < 0.0) {
            return -1.0;
        }

        vec3 intersection = rayOrigin + t * rayDir;

        // Compute distance to ring center
        float d = length(intersection - ring.center);
        if (d >= ring.innerRadius && d <= ring.outerRadius) {
            return t;
        }
        return -1.0;
    }
}

vec3 panoramaColor(sampler2D tex, vec3 dir) {
    vec2 uv = vec2(0.5 - atan(dir.z, dir.x) / PI * 0.5, 0.5 - asin(dir.y) / PI);
    return texture2D(tex, uv).rgb;
}

vec3 accel(float h2, vec3 pos) {
    float r2 = dot(pos, pos);
    float r = sqrt(r2);
    
    // Prevent division by zero and numerical instability
    if (r < 0.01) {
        return vec3(0.0);
    }
    
    float r3 = r2 * r;
    float r5 = r2 * r3;
    
    // Improved gravitational acceleration with angular momentum term
    // Uses proper relativistic corrections for better visual accuracy
    vec3 acc = -1.5 * h2 * pos / r5;
    
    // Add additional relativistic term for more accurate lensing
    acc += -pos / r3 * (1.0 + 1.5 * h2 / r2);
    
    return acc;
}

vec4 quadFromAxisAngle(vec3 axis, float angle) {
    vec4 qr;
    float half_angle = (angle * 0.5) * 3.14159 / 180.0;
    qr.x = axis.x * sin(half_angle);
    qr.y = axis.y * sin(half_angle);
    qr.z = axis.z * sin(half_angle);
    qr.w = cos(half_angle);
    return qr;
}

vec4 quadConj(vec4 q) { return vec4(-q.x, -q.y, -q.z, q.w); }

vec4 quat_mult(vec4 q1, vec4 q2) {
    vec4 qr;
    qr.x = (q1.w * q2.x) + (q1.x * q2.w) + (q1.y * q2.z) - (q1.z * q2.y);
    qr.y = (q1.w * q2.y) - (q1.x * q2.z) + (q1.y * q2.w) + (q1.z * q2.x);
    qr.z = (q1.w * q2.z) + (q1.x * q2.y) - (q1.y * q2.x) + (q1.z * q2.w);
    qr.w = (q1.w * q2.w) - (q1.x * q2.x) - (q1.y * q2.y) - (q1.z * q2.z);
    return qr;
}

vec3 rotateVector(vec3 position, vec3 axis, float angle) {
    vec4 qr = quadFromAxisAngle(axis, angle);
    vec4 qr_conj = quadConj(qr);
    vec4 q_pos = vec4(position.x, position.y, position.z, 0);

    vec4 q_tmp = quat_mult(qr, q_pos);
    qr = quat_mult(q_tmp, qr_conj);

    return vec3(qr.x, qr.y, qr.z);
}

#define IN_RANGE(x, a, b) (((x) > (a)) && ((x) < (b)))

void cartesianToSpherical(in vec3 xyz, out float rho, out float phi,
out float theta) {
    rho = sqrt((xyz.x * xyz.x) + (xyz.y * xyz.y) + (xyz.z * xyz.z));
    phi = asin(xyz.y / rho);
    theta = atan(xyz.z, xyz.x);
}

// Convert from Cartesian to spherical coord (rho, phi, theta)
// https://en.wikipedia.org/wiki/Spherical_coordinate_system
vec3 toSpherical(vec3 p) {
    float rho = sqrt((p.x * p.x) + (p.y * p.y) + (p.z * p.z));
    float theta = atan(p.z, p.x);
    float phi = asin(p.y / rho);
    return vec3(rho, theta, phi);
}

vec3 toSpherical2(vec3 pos) {
    vec3 radialCoords;
    radialCoords.x = length(pos) * 1.5 + 0.55;
    radialCoords.y = atan(-pos.x, -pos.z) * 1.5;
    radialCoords.z = abs(pos.y);
    return radialCoords;
}

void ringColor(vec3 rayOrigin, vec3 rayDir, Ring ring, inout float minDistance,
inout vec3 color) {
    float distance = ringDistance(rayOrigin, normalize(rayDir), ring);
    if (distance >= EPSILON && distance < minDistance &&
    distance <= length(rayDir) + EPSILON) {
        minDistance = distance;

        vec3 intersection = rayOrigin + normalize(rayDir) * minDistance;
        vec3 ringColor;

        {
            float dist = length(intersection);

            float v = clamp((dist - ring.innerRadius) /
            (ring.outerRadius - ring.innerRadius),
            0.0, 1.0);

            vec3 base = cross(ring.normal, vec3(0.0, 0.0, 1.0));
            float angle = acos(dot(normalize(base), normalize(intersection)));
            if (dot(cross(base, intersection), ring.normal) < 0.0)
            angle = -angle;

            float u = 0.5 - 0.5 * angle / PI;
            // HACK
            u += time * ring.rotateSpeed;

            vec3 color = vec3(0.0, 0.5, 0.0);
            // HACK
            float alpha = 0.5;
            ringColor = vec3(color);
        }

        color += ringColor;
    }
}

mat3 lookAt(vec3 origin, vec3 target, float roll) {
    vec3 rr = vec3(sin(roll), cos(roll), 0.0);
    vec3 ww = normalize(target - origin);
    vec3 uu = normalize(cross(ww, rr));
    vec3 vv = normalize(cross(uu, ww));

    return mat3(uu, vv, ww);
}

float sqrLength(vec3 a) { return dot(a, a); }

void adiskColor(vec3 pos, inout vec3 color, inout float alpha) {
    float innerRadius = 2.6;
    float outerRadius = 12.0;

    // Early distance check for performance
    float distFromCenter = length(pos);
    if (distFromCenter > outerRadius || distFromCenter < innerRadius) {
        return;
    }

    // Density linearly decreases as the distance to the blackhole center
    // increases.
    float density = max(
    0.0, 1.0 - length(pos.xyz / vec3(outerRadius, adiskHeight, outerRadius)));
    if (density < 0.001) {
        return;
    }

    density *= pow(1.0 - abs(pos.y) / adiskHeight, adiskDensityV);

    // Set particle density to 0 when radius is below the innermost stable circular orbit.
    density *= smoothstep(innerRadius, innerRadius * 1.1, distFromCenter);

    // Avoid shader computation when density is very small.
    if (density < 0.001) {
        return;
    }

    vec3 sphericalCoord = toSpherical(pos);

    // Scale the rho and phi so that the particles appear to be at the correct
    // scale visually.
    sphericalCoord.y *= 2.0;
    sphericalCoord.z *= 4.0;

    density *= 1.0 / pow(sphericalCoord.x, adiskDensityH);
    
    // Temperature-based coloring - hotter closer to black hole
    float temperature = 1.0 / (distFromCenter * 0.3 + 0.1);
    temperature = clamp(temperature, 0.0, 3.0);
    
    // Blackbody radiation color approximation
    vec3 temperatureColor;
    if (temperature > 2.0) {
        // Very hot: blue-white
        temperatureColor = mix(vec3(0.8, 0.9, 1.0), vec3(1.0, 1.0, 1.0), (temperature - 2.0));
    } else if (temperature > 1.0) {
        // Hot: white-yellow
        temperatureColor = mix(vec3(1.0, 0.8, 0.4), vec3(0.8, 0.9, 1.0), (temperature - 1.0));
    } else {
        // Cooler: red-orange
        temperatureColor = mix(vec3(0.5, 0.2, 0.1), vec3(1.0, 0.8, 0.4), temperature);
    }

    if (adiskParticle < 0.5) {
        color += temperatureColor * density * 0.02;
        return;
    }

    // Enhanced noise with better turbulence
    float noise = 1.0;
    vec3 noiseCoord = sphericalCoord;
    
    for (int i = 0; i < int(adiskNoiseLOD); i++) {
        float scale = pow(2.0, float(i)) * adiskNoiseScale;
        float amplitude = 0.5 / pow(2.0, float(i) * 0.5);
        
        noise *= amplitude * snoise(noiseCoord * scale) + (1.0 - amplitude);
        
        // Differential rotation based on distance
        float rotationSpeed = 1.0 / sqrt(distFromCenter) * adiskSpeed;
        if (i % 2 == 0) {
            noiseCoord.y += time * rotationSpeed;
        } else {
            noiseCoord.y -= time * rotationSpeed * 0.7;
        }
    }

    // Enhanced color mixing
    vec3 dustColor = texture(colorMap, vec2(sphericalCoord.x / outerRadius, 0.5)).rgb;
    vec3 finalColor = mix(dustColor, temperatureColor, 0.6) * temperatureColor;
    
    // Add some emission glow for hot regions
    float emission = pow(temperature, 2.0) * 0.1;
    finalColor += temperatureColor * emission;

    density *= 8000.0; // Reduced from 16000 for better balance
    color += density * adiskLit * finalColor * alpha * abs(noise);
}

vec3 traceColor(vec3 pos, vec3 dir) {
    vec3 color = vec3(0.0);
    float alpha = 1.0;
    bool hitEventHorizon = false;

    // Black hole center and event horizon radius
    vec3 blackHoleCenter = vec3(0.0, 0.0, 0.0);
    float eventHorizonRadius = 1.0;
    float photonSphere = 1.5; // Photon sphere radius for better physics

    // Calculate initial distance to black hole
    float initialDist = length(pos - blackHoleCenter);
    
    // Improved adaptive step size with logarithmic scaling
    float baseStepSize = min(0.5, initialDist * 0.08);
    dir = normalize(dir) * baseStepSize;

    // Initial values for angular momentum conservation
    vec3 relativePos = pos - blackHoleCenter;
    vec3 h = cross(relativePos, dir);
    float h2 = dot(h, h);
    
    // Early exit if starting inside event horizon
    if (initialDist < eventHorizonRadius) {
        return vec3(0.0);
    }

    // Dynamic iteration count based on initial distance
    int maxIterations = int(min(500.0, 100.0 + initialDist * 20.0));
    
    float totalDistance = 0.0;
    float maxDistance = 150.0; // Increased for better far-field sampling
    
    for (int i = 0; i < maxIterations; i++) {
        float distToBlackHole = length(pos - blackHoleCenter);
        
        if (renderBlackHole > 0.5) {
            // Check if we've hit the event horizon
            if (distToBlackHole < eventHorizonRadius) {
                hitEventHorizon = true;
                return vec3(0.0);
            }

            // Improved adaptive step size with smoother transitions
            float stepFactor = 1.0;
            if (distToBlackHole < photonSphere) {
                // Very close to photon sphere - use smallest steps
                stepFactor = 0.02;
            } else if (distToBlackHole < 5.0) {
                // Near field - small steps for accuracy
                stepFactor = mix(0.02, 0.05, (distToBlackHole - photonSphere) / (5.0 - photonSphere));
            } else if (distToBlackHole < 20.0) {
                // Mid field - medium steps
                stepFactor = mix(0.05, 0.1, (distToBlackHole - 5.0) / 15.0);
            } else {
                // Far field - larger steps for performance
                stepFactor = min(0.3, distToBlackHole * 0.01);
            }
            
            float currentStepSize = baseStepSize * stepFactor;
            
            // If gravitational lensing is applied
            if (gravatationalLensing > 0.5) {
                vec3 relativePos = pos - blackHoleCenter;
                vec3 acc = accel(h2, relativePos);
                
                // Scale acceleration by step size for stability
                dir += acc * currentStepSize;
                dir = normalize(dir) * currentStepSize;
            } else {
                dir = normalize(dir) * currentStepSize;
            }
            
            // Sample accretion disk with distance-based intensity
            if (adiskEnabled > 0.5) {
                float diskSampling = 1.0;
                // Reduce sampling frequency when far from disk
                if (abs(pos.y) > 2.0 || distToBlackHole > 15.0) {
                    diskSampling = 0.3;
                }
                
                if (diskSampling > 0.5 || i % 3 == 0) {
                    adiskColor(pos, color, alpha);
                }
            }
        }

        pos += dir;
        totalDistance += length(dir);
        
        // Enhanced termination conditions
        float currentDist = length(pos - blackHoleCenter);
        
        // Break if we've traveled too far
        if (totalDistance > maxDistance) {
            break;
        }
        
        // Break if we're moving away and far enough
        if (currentDist > 50.0 && currentDist > initialDist) {
            break;
        }
        
        // Early exit for rays that will clearly escape
        if (currentDist > 30.0 && dot(normalize(pos - blackHoleCenter), normalize(dir)) > 0.8) {
            break;
        }
    }

    // Enhanced skybox sampling with distance-based intensity
    if (!hitEventHorizon) {
        vec3 finalDir = normalize(dir);
        vec3 skyboxColor = texture(galaxy, finalDir).rgb;
        
        // Add subtle color shift based on gravitational redshift
        if (gravatationalLensing > 0.5 && length(pos - blackHoleCenter) < 10.0) {
            float redshift = 1.0 / sqrt(1.0 - 2.0 / length(pos - blackHoleCenter));
            skyboxColor.rgb *= vec3(redshift * 0.9, redshift * 0.95, redshift * 1.0);
        }
        
        color += skyboxColor;
    }
    
    return color;
}

void main() {
    // Use camera uniforms for dynamic camera control
    vec2 uv = gl_FragCoord.xy / resolution.xy - vec2(0.5);
    uv.x *= cameraAspect;

    // Calculate ray direction using proper camera vectors and FOV
    float tanHalfFov = tan(radians(cameraFov) * 0.5);
    vec3 rayDir = normalize(cameraFront + cameraRight * uv.x * tanHalfFov + cameraUp * uv.y * tanHalfFov);
    vec3 rayPos = cameraPos;
    
    // Use the complex ray tracing function from blackhole_main.frag
    vec3 color = traceColor(rayPos, rayDir);
    fragColor = vec4(color, 1.0);
}