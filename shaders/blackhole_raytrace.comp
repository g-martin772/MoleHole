#version 460 core

layout(local_size_x = 16, local_size_y = 16) in;
layout(rgba32f, binding = 0) uniform image2D outputImage;

uniform sampler2D u_skyboxTexture;
uniform vec3 u_cameraPos;
uniform vec3 u_cameraFront;
uniform vec3 u_cameraUp;
uniform vec3 u_cameraRight;
uniform float u_fov;
uniform float u_aspect;
uniform int u_numBlackHoles;
uniform vec3 u_blackHolePositions[8];
uniform float u_blackHoleMasses[8];
uniform bool u_showAccretionDisks[8];
uniform float u_accretionDiskSizes[8];
uniform vec3 u_accretionDiskColors[8];
uniform float u_time;

uniform float u_blackHoleSpins[8];
uniform vec3 u_blackHoleSpinAxes[8];

uniform sampler3D u_kerrLookupTable;
uniform bool u_useKerrDistortion;
uniform float u_kerrLutMaxDistance;
uniform int u_kerrLutResolution;
uniform int u_debugMode;

const float G = 1.0;
const float c = 1.0;
const float c2 = c * c;

const int MAX_STEPS = 1000;
const float MIN_DISTANCE = 0.001;
const float MAX_DISTANCE = 1000.0;
const float STEP_SIZE = 0.01;
const float PI = 3.14159265359;

const float EVENT_HORIZON_SAFETY_FACTOR = 1.5;
const float KERR_INFLUENCE_RADIUS_FACTOR = 100.0;
const float KERR_DISTANCE_FALLOFF_FACTOR = 20.0;
const float FRAME_DRAG_STRENGTH_MULTIPLIER = 0.1;
const float MAX_GRAVITATIONAL_DEFLECTION = 0.5;
const float MAX_FRAME_DRAG_DEFLECTION = 0.2;
const float MIN_IMPACT_PARAMETER = 1e-6;
const float MIN_DISTANCE_THRESHOLD = 1e-6;

const float DEBUG_DEFLECTION_THRESHOLD = 0.001;
const float DEBUG_DEFLECTION_SCALE = 10.0;
const float DEBUG_GRAVITATIONAL_SCALE = 100.0;
const float DEBUG_GRAVITATIONAL_RADIUS_FACTOR = 10.0;

float schwarzschildRadius(float mass) {
    return (2.0 * G * mass) / c2;
}


/**
 * KERR EVENT HORIZONS
 * Formula: r± = M ± √(M² - a²)
 *
 * Outer horizon (r₊): Event horizon where nothing can escape
 * Inner horizon (r₋): Cauchy horizon (unstable in realistic scenarios)
 *
 * For |a| ≤ M: Physical black hole (extremal when |a| = M)
 * For |a| > M: Naked singularity (unphysical)
 */
vec2 kerrEventHorizons(float mass, float spin) {
    float a = abs(spin);
    float discriminant = mass * mass - a * a;

    // Ensure physical black hole (avoid naked singularity)
    if (discriminant < 0.0) {
        // Clamp to extremal case
        a = mass;
        discriminant = 0.0;
    }

    float sqrt_discriminant = sqrt(discriminant);
    float r_plus = mass + sqrt_discriminant;   // Outer event horizon
    float r_minus = mass - sqrt_discriminant;  // Inner event horizon

    return vec2(r_minus, r_plus);
}

vec2 directionToSpherical(vec3 direction) {
    vec3 d = normalize(direction);
    float theta = atan(d.z, d.x);
    float phi = asin(d.y);

    float u = (theta + PI) / (2.0 * PI);
    float v = (phi + PI * 0.5) / PI;

    return vec2(u, v);
}

vec3 sampleSkybox(vec3 direction) {
    vec2 uv = directionToSpherical(direction);
    return texture(u_skyboxTexture, uv).rgb;
}

float blackHoleDistance(vec3 pos, vec3 blackHolePos, float mass, float spin) {
    float dist = distance(pos, blackHolePos);
    float r_plus = kerrEventHorizons(mass, spin).y;
    return dist - r_plus;
}

float sceneDistance(vec3 pos) {
    float minDist = MAX_DISTANCE;

    for (int i = 0; i < u_numBlackHoles; i++) {
        float dist = blackHoleDistance(pos, u_blackHolePositions[i], u_blackHoleMasses[i], u_blackHoleSpins[i]);
        minDist = min(minDist, dist);
    }

    return minDist;
}

vec2 computeKerrDeflection(vec3 pos, vec3 rayDir, vec3 bhPos, float mass, float spin, vec3 spinAxis) {
    vec3 r_vec = pos - bhPos;
    float r = length(r_vec);

    if (r < MIN_DISTANCE_THRESHOLD) return vec2(0.0);

    float r_plus = kerrEventHorizons(mass, spin).y;

    vec3 k = normalize(rayDir);
    vec3 r_unit = r_vec / r;

    vec3 b_vec = cross(r_vec, k);
    float b = length(b_vec);

    if (b < MIN_IMPACT_PARAMETER) return vec2(0.0);

    float gravitational_strength = r_plus / (r * r);
    float distance_falloff = exp(-r / (r_plus * KERR_DISTANCE_FALLOFF_FACTOR));

    vec3 toward_bh = -r_unit;
    float radial_component = dot(k, toward_bh);

    vec3 perp_deflection = toward_bh - radial_component * k;
    perp_deflection = normalize(perp_deflection);

    float alpha = 2.0 * r_plus / b;
    alpha *= distance_falloff;
    alpha = clamp(alpha, 0.0, MAX_GRAVITATIONAL_DEFLECTION);

    vec3 frame_drag_axis = normalize(spinAxis);
    vec3 angular_momentum = cross(r_vec, k);
    float frame_drag_strength = spin * r_plus * mass / (r * r * r);
    frame_drag_strength *= distance_falloff;

    vec3 frame_drag_direction = cross(frame_drag_axis, angular_momentum);
    if (length(frame_drag_direction) > MIN_DISTANCE_THRESHOLD) {
        frame_drag_direction = normalize(frame_drag_direction);
    } else {
        frame_drag_direction = vec3(0.0);
    }

    float beta = frame_drag_strength * FRAME_DRAG_STRENGTH_MULTIPLIER;
    beta = clamp(beta, 0.0, MAX_FRAME_DRAG_DEFLECTION);

    vec3 deflected_dir = k + alpha * perp_deflection + beta * frame_drag_direction;
    deflected_dir = normalize(deflected_dir);

    float theta_old = acos(clamp(k.y, -1.0, 1.0));
    float phi_old = atan(k.z, k.x);

    float theta_new = acos(clamp(deflected_dir.y, -1.0, 1.0));
    float phi_new = atan(deflected_dir.z, deflected_dir.x);

    float dphi = phi_new - phi_old;
    if (dphi > PI) dphi -= 2.0 * PI;
    else if (dphi < -PI) dphi += 2.0 * PI;

    return vec2(theta_new - theta_old, dphi);
}

vec3 applyKerrDistortion(vec3 rayPos, vec3 rayDir, int blackHoleIndex) {
    if (!u_useKerrDistortion) {
        return rayDir;
    }

    if (blackHoleIndex < 0 || blackHoleIndex >= u_numBlackHoles) {
        return rayDir;
    }

    // Use a loop to safely access array elements
    vec3 bhPos = vec3(0.0);
    float mass = 0.0;
    float spin = 0.0;
    vec3 spinAxis = vec3(0.0, 1.0, 0.0);

    for (int i = 0; i < u_numBlackHoles; i++) {
        bhPos = u_blackHolePositions[i];
        mass = u_blackHoleMasses[i];
        spin = u_blackHoleSpins[i];
        spinAxis = u_blackHoleSpinAxes[i];
        break;
    }

    float distance = length(rayPos - bhPos);
    float r_plus = kerrEventHorizons(mass, spin).y;
    float influenceRadius = r_plus * KERR_INFLUENCE_RADIUS_FACTOR;

    if (distance > influenceRadius) {
        return rayDir;
    }

    vec2 deflection = computeKerrDeflection(rayPos, rayDir, bhPos, mass, spin, spinAxis);

    vec3 normDir = normalize(rayDir);
    float currentTheta = acos(clamp(normDir.y, -1.0, 1.0));
    float currentPhi = atan(normDir.z, normDir.x);

    float newTheta = currentTheta + deflection.x;
    float newPhi = currentPhi + deflection.y;

    newTheta = clamp(newTheta, 0.01, PI - 0.01);

    vec3 deflectedDir = vec3(
        sin(newTheta) * cos(newPhi),
        cos(newTheta),
        sin(newTheta) * sin(newPhi)
    );

    return normalize(deflectedDir);
}

vec3 debugVisualization(vec3 rayPos, vec3 rayDir) {
    if (u_debugMode == 0) return vec3(0.0);

    for (int i = 0; i < u_numBlackHoles; i++) {
        vec3 bhPos = u_blackHolePositions[i];
        float distance = length(rayPos - bhPos);
        float r_plus = kerrEventHorizons(u_blackHoleMasses[i], u_blackHoleSpins[i]).y;

        if (u_debugMode == 1) {
            float influence = r_plus * KERR_INFLUENCE_RADIUS_FACTOR;
            if (distance < influence && distance > r_plus * EVENT_HORIZON_SAFETY_FACTOR) {
                float intensity = 1.0 - (distance / influence);
                return vec3(intensity, 0.0, 0.0);
            }
        }

        if (u_debugMode == 2) {
            if (distance > r_plus * EVENT_HORIZON_SAFETY_FACTOR) {
                vec2 deflection = computeKerrDeflection(rayPos, rayDir, bhPos,
                                                      u_blackHoleMasses[i],
                                                      u_blackHoleSpins[i],
                                                      u_blackHoleSpinAxes[i]);
                float deflectionMag = length(deflection);
                if (deflectionMag > DEBUG_DEFLECTION_THRESHOLD) {
                    return vec3(deflectionMag * DEBUG_DEFLECTION_SCALE, deflectionMag * DEBUG_DEFLECTION_SCALE * 0.5, 0.0);
                }
            }
        }

        if (u_debugMode == 3) {
            if (distance < r_plus * DEBUG_GRAVITATIONAL_RADIUS_FACTOR && distance > r_plus * EVENT_HORIZON_SAFETY_FACTOR) {
                float gravStrength = r_plus / (distance * distance);
                return vec3(0.0, gravStrength * DEBUG_GRAVITATIONAL_SCALE, 0.0);
            }
        }

        if (u_debugMode == 4) {
            if (distance <= r_plus * 3.0) {
                if (distance <= r_plus) {
                    return vec3(0.0);
                } else {
                    float gradient = (distance - r_plus) / (r_plus * 2.0);
                    gradient = clamp(gradient, 0.0, 1.0);
                    return vec3(gradient * 0.5, gradient * 0.8, gradient);
                }
            }
        }
    }

    return vec3(0.0);
}

// Add new function to check if ray will hit any black hole
bool checkEventHorizonCrossing(vec3 pos, vec3 dir, out int hitBlackHoleIndex) {
    hitBlackHoleIndex = -1;

    for (int i = 0; i < u_numBlackHoles; i++) {
        vec3 bhPos = u_blackHolePositions[i];
        float r_plus = kerrEventHorizons(u_blackHoleMasses[i], u_blackHoleSpins[i]).y;

        vec3 toBlackHole = bhPos - pos;
        float distanceToCenter = length(toBlackHole);

        // If already inside event horizon
        if (distanceToCenter <= r_plus) {
            hitBlackHoleIndex = i;
            return true;
        }

        // Check if ray direction points toward black hole and will cross event horizon
        vec3 dirToCenter = normalize(toBlackHole);
        float rayDotToCenter = dot(normalize(dir), dirToCenter);

        // Only check rays pointing somewhat toward the black hole
        if (rayDotToCenter > 0.0) {
            // Calculate closest approach distance using ray-sphere intersection
            vec3 rayToCenter = pos - bhPos;
            float a = dot(dir, dir);
            float b = 2.0 * dot(rayToCenter, dir);
            float c = dot(rayToCenter, rayToCenter) - r_plus * r_plus;
            float discriminant = b * b - 4.0 * a * c;

            // If discriminant >= 0, ray intersects event horizon sphere
            if (discriminant >= 0.0) {
                float t1 = (-b - sqrt(discriminant)) / (2.0 * a);
                float t2 = (-b + sqrt(discriminant)) / (2.0 * a);

                // Check if intersection is in front of ray (t > 0)
                if (t1 > 0.0 || t2 > 0.0) {
                    hitBlackHoleIndex = i;
                    return true;
                }
            }
        }
    }
    return false;
}

vec3 rayMarch(vec3 rayPos, vec3 rayDir) {
    vec3 currentPos = rayPos;
    vec3 currentDir = rayDir;
    vec3 color = vec3(0.0);
    float totalDistance = 0.0;
    bool hitBlackHole = false;
    int hitBlackHoleIndex = -1;

    vec3 debugColor = debugVisualization(rayPos, rayDir);
    if (length(debugColor) > 0.0) {
        return debugColor;
    }

    for (int step = 0; step < MAX_STEPS; step++) {
        vec3 stepDebugColor = debugVisualization(currentPos, currentDir);
        if (length(stepDebugColor) > 0.0) {
            return stepDebugColor;
        }

        // Check if current position or trajectory will hit any black hole
        int crossingBlackHoleIndex;
        if (checkEventHorizonCrossing(currentPos, currentDir, crossingBlackHoleIndex)) {
            hitBlackHole = true;
            hitBlackHoleIndex = crossingBlackHoleIndex;
            color = vec3(0.0);
            break;
        }

        float dist = sceneDistance(currentPos);

        // Apply Kerr distortion before stepping
        if (u_useKerrDistortion) {
            for (int i = 0; i < u_numBlackHoles; i++) {
                vec3 bhPos = u_blackHolePositions[i];
                float bhDistance = length(currentPos - bhPos);
                float r_plus = kerrEventHorizons(u_blackHoleMasses[i], u_blackHoleSpins[i]).y;

                if (bhDistance < r_plus * KERR_INFLUENCE_RADIUS_FACTOR) {
                    currentDir = applyKerrDistortion(currentPos, currentDir, i);
                }
            }
        }

        // After applying distortion, check again if the bent ray will hit a black hole
        if (checkEventHorizonCrossing(currentPos, currentDir, crossingBlackHoleIndex)) {
            hitBlackHole = true;
            hitBlackHoleIndex = crossingBlackHoleIndex;
            color = vec3(0.0);
            break;
        }

        float stepDist = max(dist, STEP_SIZE);
        currentPos += currentDir * stepDist;
        totalDistance += stepDist;

        if (totalDistance > MAX_DISTANCE) {
            break;
        }
    }

    if (!hitBlackHole && length(color) < 0.01) {
        color = sampleSkybox(currentDir);
    }

    return color;
}

void main() {
    ivec2 texCoords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imageSize = imageSize(outputImage);

    if (texCoords.x >= imageSize.x || texCoords.y >= imageSize.y) {
        return;
    }

    vec2 uv = (vec2(texCoords) + 0.5) / vec2(imageSize);
    uv = uv * 2.0 - 1.0;
    uv.x *= u_aspect;

    float tanHalfFov = tan(radians(u_fov) * 0.5);
    vec3 rayDir = normalize(u_cameraFront + u_cameraRight * uv.x * tanHalfFov + u_cameraUp * uv.y * tanHalfFov);
    vec3 rayPos = u_cameraPos;

    vec3 finalColor = rayMarch(rayPos, rayDir);

    finalColor = finalColor / (finalColor + vec3(1.0));
    finalColor = pow(finalColor, vec3(1.0 / 2.2));

    imageStore(outputImage, texCoords, vec4(finalColor, 1.0));
}