#version 460 core

layout(local_size_x = 16, local_size_y = 16) in;
layout(rgba32f, binding = 0) uniform image2D outputImage;

uniform sampler2D u_skyboxTexture;
uniform vec3 u_cameraPos;
uniform vec3 u_cameraFront;
uniform vec3 u_cameraUp;
uniform vec3 u_cameraRight;
uniform float u_fov;
uniform float u_aspect;
uniform int u_numBlackHoles;
uniform vec3 u_blackHolePositions[8];
uniform float u_blackHoleMasses[8];
uniform bool u_showAccretionDisks[8];
uniform float u_accretionDiskSizes[8];
uniform vec3 u_accretionDiskColors[8];
uniform float u_time;

const float G = 1.0;
const float c = 1.0;
const float c2 = c * c;

const int MAX_STEPS = 1000; //256;
const float MIN_DISTANCE = 0.001;
const float MAX_DISTANCE = 1000.0;
const float STEP_SIZE = 0.01;
const float PI = 3.14159265359;

float schwarzschildRadius(float mass) {
    return (2.0 * G * mass) / c2;
}

vec2 directionToSpherical(vec3 direction) {
    vec3 d = normalize(direction);
    float theta = atan(d.z, d.x);
    float phi = asin(d.y);

    float u = (theta + PI) / (2.0 * PI);
    float v = (phi + PI * 0.5) / PI;

    return vec2(u, v);
}

vec3 sampleSkybox(vec3 direction) {
    vec2 uv = directionToSpherical(direction);
    return texture(u_skyboxTexture, uv).rgb;
}

float blackHoleDistance(vec3 pos, vec3 blackHolePos, float mass) {
    float dist = distance(pos, blackHolePos);
    float rs = schwarzschildRadius(mass);
    return dist - rs;
}

float sceneDistance(vec3 pos) {
    float minDist = MAX_DISTANCE;

    for (int i = 0; i < u_numBlackHoles; i++) {
        float dist = blackHoleDistance(pos, u_blackHolePositions[i], u_blackHoleMasses[i]);
        minDist = min(minDist, dist);
    }

    return minDist;
}

vec3 rayMarch(vec3 rayPos, vec3 rayDir) {
    vec3 currentPos = rayPos;
    vec3 color = vec3(0.0);
    float totalDistance = 0.0;
    bool hitBlackHole = false;

    for (int step = 0; step < MAX_STEPS; step++) {
        float dist = sceneDistance(currentPos);

        if (dist < MIN_DISTANCE) {
            hitBlackHole = true;
            color = vec3(0.0); // Black holes are black
            break;
        }

        currentPos += rayDir * max(dist, STEP_SIZE);
        totalDistance += max(dist, STEP_SIZE);

        if (totalDistance > MAX_DISTANCE) {
            break;
        }
    }

    if (!hitBlackHole && length(color) < 0.01) {
        color = sampleSkybox(rayDir);
    }

    return color;
}

void main() {
    ivec2 texCoords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imageSize = imageSize(outputImage);

    if (texCoords.x >= imageSize.x || texCoords.y >= imageSize.y) {
        return;
    }

    vec2 uv = (vec2(texCoords) + 0.5) / vec2(imageSize);
    uv = uv * 2.0 - 1.0;
    uv.x *= u_aspect;

    float tanHalfFov = tan(radians(u_fov) * 0.5);
    vec3 rayDir = normalize(u_cameraFront + u_cameraRight * uv.x * tanHalfFov + u_cameraUp * uv.y * tanHalfFov);
    vec3 rayPos = u_cameraPos;

    vec3 finalColor = rayMarch(rayPos, rayDir);

    finalColor = finalColor / (finalColor + vec3(1.0));
    finalColor = pow(finalColor, vec3(1.0 / 2.2));

    imageStore(outputImage, texCoords, vec4(finalColor, 1.0));
}