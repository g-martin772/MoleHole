#version 460 core

layout(local_size_x = 16, local_size_y = 16) in;
layout(rgba32f, binding = 0) uniform image2D outputImage;

uniform sampler2D u_skyboxTexture;
uniform vec3 u_cameraPos;
uniform vec3 u_cameraFront;
uniform vec3 u_cameraUp;
uniform vec3 u_cameraRight;
uniform float u_fov;
uniform float u_aspect;
uniform int u_numBlackHoles;
uniform vec3 u_blackHolePositions[8];
uniform float u_blackHoleMasses[8];
uniform bool u_showAccretionDisks[8];
uniform float u_accretionDiskSizes[8];
uniform vec3 u_accretionDiskColors[8];
uniform float u_time;

const float G = 1.0;
const float c = 1.0;
const float c2 = c * c;

const int MAX_STEPS = 256;
const float MIN_DISTANCE = 0.001;
const float MAX_DISTANCE = 1000.0;
const float STEP_SIZE = 0.1;
const float PI = 3.14159265359;

float schwarzschildRadius(float mass) {
    return (2.0 * G * mass) / c2;
}

vec2 directionToSpherical(vec3 direction) {
    vec3 d = normalize(direction);
    float theta = atan(d.z, d.x);
    float phi = asin(d.y);

    float u = (theta + PI) / (2.0 * PI);
    float v = (phi + PI * 0.5) / PI;

    return vec2(u, v);
}

vec3 sampleSkybox(vec3 direction) {
    vec2 uv = directionToSpherical(direction);
    return texture(u_skyboxTexture, uv).rgb;
}

vec3 deflectRay(vec3 rayPos, vec3 rayDir, vec3 blackHolePos, float mass) {
    vec3 toBlackHole = blackHolePos - rayPos;
    float distance = length(toBlackHole);

    if (distance < MIN_DISTANCE) return rayDir;

    float rs = schwarzschildRadius(mass);
    float deflectionStrength = (2.0 * rs) / distance;

    vec3 normalized = normalize(toBlackHole);
    vec3 perpendicular = cross(rayDir, cross(rayDir, normalized));

    return normalize(rayDir + perpendicular * deflectionStrength * 0.5);
}

bool hitEventHorizon(vec3 rayPos, vec3 blackHolePos, float mass) {
    float distance = length(rayPos - blackHolePos);
    float rs = schwarzschildRadius(mass);
    return distance <= rs * 1.1;
}

void main() {
    ivec2 texCoords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imageSize = imageSize(outputImage);

    if (texCoords.x >= imageSize.x || texCoords.y >= imageSize.y) {
        return;
    }

    vec2 uv = (vec2(texCoords) + 0.5) / vec2(imageSize);
    uv = uv * 2.0 - 1.0;
    uv.x *= u_aspect;

    float tanHalfFov = tan(radians(u_fov) * 0.5);
    vec3 rayDir = normalize(u_cameraFront + u_cameraRight * uv.x * tanHalfFov + u_cameraUp * uv.y * tanHalfFov);
    vec3 rayPos = u_cameraPos;

    vec3 finalColor = vec3(0.0);
    bool hitSomething = false;

    for (int step = 0; step < MAX_STEPS; step++) {
        for (int i = 0; i < u_numBlackHoles; i++) {
            if (hitEventHorizon(rayPos, u_blackHolePositions[i], u_blackHoleMasses[i])) {
                finalColor = vec3(0.0);
                hitSomething = true;
                break;
            }
        }

        if (hitSomething) break;

        for (int i = 0; i < u_numBlackHoles; i++) {
            rayDir = deflectRay(rayPos, rayDir, u_blackHolePositions[i], u_blackHoleMasses[i]);
        }

        rayPos += rayDir * STEP_SIZE;

        if (length(rayPos - u_cameraPos) > MAX_DISTANCE) {
            finalColor = sampleSkybox(rayDir);
            break;
        }
    }

    if (!hitSomething && length(finalColor) == 0.0) {
        finalColor = sampleSkybox(rayDir);
    }

    finalColor = finalColor / (finalColor + vec3(1.0));
    finalColor = pow(finalColor, vec3(1.0 / 2.2));

    imageStore(outputImage, texCoords, vec4(finalColor, 1.0));
}
