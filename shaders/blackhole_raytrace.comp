#version 460 core

layout(local_size_x = 16, local_size_y = 16) in;
layout(rgba32f, binding = 0) uniform image2D outputImage;

uniform sampler2D u_skyboxTexture;
uniform vec3 u_cameraPos;
uniform vec3 u_cameraFront;
uniform vec3 u_cameraUp;
uniform vec3 u_cameraRight;
uniform float u_fov;
uniform float u_aspect;
uniform int u_numBlackHoles;
uniform vec3 u_blackHolePositions[8];
uniform float u_blackHoleMasses[8];
uniform bool u_showAccretionDisks[8];
uniform float u_accretionDiskSizes[8];
uniform vec3 u_accretionDiskColors[8];
uniform float u_time;

uniform sampler3D u_kerrLookupTable;
uniform bool u_useKerrDistortion;
uniform float u_kerrLutMaxDistance;
uniform int u_kerrLutResolution;

const float G = 1.0;
const float c = 1.0;
const float c2 = c * c;

const int MAX_STEPS = 1000; //256;
const float MIN_DISTANCE = 0.001;
const float MAX_DISTANCE = 1000.0;
const float STEP_SIZE = 0.01;
const float PI = 3.14159265359;

float schwarzschildRadius(float mass) {
    return (2.0 * G * mass) / c2;
}

vec2 directionToSpherical(vec3 direction) {
    vec3 d = normalize(direction);
    float theta = atan(d.z, d.x);
    float phi = asin(d.y);

    float u = (theta + PI) / (2.0 * PI);
    float v = (phi + PI * 0.5) / PI;

    return vec2(u, v);
}

vec3 sampleSkybox(vec3 direction) {
    vec2 uv = directionToSpherical(direction);
    return texture(u_skyboxTexture, uv).rgb;
}

float blackHoleDistance(vec3 pos, vec3 blackHolePos, float mass) {
    float dist = distance(pos, blackHolePos);
    float rs = schwarzschildRadius(mass);
    return dist - rs;
}

float sceneDistance(vec3 pos) {
    float minDist = MAX_DISTANCE;

    for (int i = 0; i < u_numBlackHoles; i++) {
        float dist = blackHoleDistance(pos, u_blackHolePositions[i], u_blackHoleMasses[i]);
        minDist = min(minDist, dist);
    }

    return minDist;
}

vec2 sampleKerrDeflection(vec3 pos, vec3 blackHolePos, float bhMass, float maxDistance, int lutResolution) {
    vec3 relPos = pos - blackHolePos;
    float distance = length(relPos);

    // Convert to spherical coordinates for LUT sampling
    float theta = acos(relPos.y / distance);
    float phi = atan(relPos.z, relPos.x);
    if (phi < 0.0) phi += 2.0 * PI;

    // Convert to normalized LUT coordinates
    float minDist = schwarzschildRadius(bhMass) * 2.0; // match generator's distance axis
    float distanceNorm = log(distance / minDist) / log(maxDistance / minDist);
    distanceNorm = clamp(distanceNorm, 0.0, 1.0);

    vec3 lutCoord = vec3(
        distanceNorm,
        theta / PI,
        phi / (2.0 * PI)
    );

    vec4 lutData = texture(u_kerrLookupTable, lutCoord);

    // Check validity flag
    if (lutData.a < 0.5) {
        return vec2(0.0); // Invalid/extreme deflection
    }

    // Clamp deflection to a reasonable physical range to avoid numerical explosions
    const float PI = 3.14159265359;
    vec2 defl = clamp(lutData.xy, vec2(-PI), vec2(PI));
    return defl;
}

vec3 applyKerrDistortion(vec3 rayPos, vec3 rayDir, int blackHoleIndex) {
    if (!u_useKerrDistortion) {
        return rayDir;
    }

    vec3 bhPos = u_blackHolePositions[blackHoleIndex];
    float distance = length(rayPos - bhPos);

    float rs = schwarzschildRadius(u_blackHoleMasses[blackHoleIndex]);
    float influenceRadius = rs * 50.0;

    if (distance > influenceRadius) {
        return rayDir;
    }

    vec2 deflection = sampleKerrDeflection(rayPos, bhPos, u_blackHoleMasses[blackHoleIndex], u_kerrLutMaxDistance, u_kerrLutResolution);

    // Convert ray direction to spherical coordinates
    vec3 normDir = normalize(rayDir);
    float currentTheta = acos(normDir.y);
    float currentPhi = atan(normDir.z, normDir.x);

    // Apply deflection
    float newTheta = currentTheta + deflection.x;
    float newPhi = currentPhi + deflection.y;

    // Convert back to Cartesian
    vec3 deflectedDir = vec3(
        sin(newTheta) * cos(newPhi),
        cos(newTheta),
        sin(newTheta) * sin(newPhi)
    );

    return normalize(deflectedDir);
}

vec3 rayMarch(vec3 rayPos, vec3 rayDir) {
    bool appliedDeflection[8];
    for (int ai = 0; ai < 8; ++ai) appliedDeflection[ai] = false;
    vec3 currentPos = rayPos;
    vec3 currentDir = rayDir;
    vec3 color = vec3(0.0);
    float totalDistance = 0.0;
    bool hitBlackHole = false;

    for (int step = 0; step < MAX_STEPS; step++) {
        float dist = sceneDistance(currentPos);

        if (dist < MIN_DISTANCE) {
            hitBlackHole = true;
            color = vec3(0.0); // Black holes are black
            break;
        }

        for (int i = 0; i < u_numBlackHoles; i++) {
            vec3 bhPos = u_blackHolePositions[i];
            float bhDistance = length(currentPos - bhPos);
            float rs = schwarzschildRadius(u_blackHoleMasses[i]);
            if (!appliedDeflection[i] && bhDistance < rs * 50.0) {
                currentDir = applyKerrDistortion(currentPos, currentDir, i);
                appliedDeflection[i] = true;
            }
        }

        currentPos += currentDir * max(dist, STEP_SIZE);
        totalDistance += max(dist, STEP_SIZE);

        if (totalDistance > MAX_DISTANCE) {
            break;
        }
    }

    if (!hitBlackHole && length(color) < 0.01) {
        color = sampleSkybox(currentDir);
    }

    return color;
}

void main() {
    ivec2 texCoords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imageSize = imageSize(outputImage);

    if (texCoords.x >= imageSize.x || texCoords.y >= imageSize.y) {
        return;
    }

    vec2 uv = (vec2(texCoords) + 0.5) / vec2(imageSize);
    uv = uv * 2.0 - 1.0;
    uv.x *= u_aspect;

    float tanHalfFov = tan(radians(u_fov) * 0.5);
    vec3 rayDir = normalize(u_cameraFront + u_cameraRight * uv.x * tanHalfFov + u_cameraUp * uv.y * tanHalfFov);
    vec3 rayPos = u_cameraPos;

    vec3 finalColor = rayMarch(rayPos, rayDir);

    finalColor = finalColor / (finalColor + vec3(1.0));
    finalColor = pow(finalColor, vec3(1.0 / 2.2));

    imageStore(outputImage, texCoords, vec4(finalColor, 1.0));
}