#version 460 core

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

// 3D texture for storing light deflection lookup table
// R,G = deflection angles (theta, phi)
// B,A = additional ray parameters
layout(rgba32f, binding = 0) uniform image3D kerrLookupTable;

uniform vec3 u_blackHolePos;
uniform float u_blackHoleMass;
uniform float u_blackHoleSpin; // dimensionless spin parameter (0 to 1)
uniform vec3 u_blackHoleSpinAxis; // normalized spin axis
uniform float u_maxDistance; // maximum distance for LUT
uniform int u_lutResolution; // resolution of the LUT (same for all 3 dimensions)

const float G = 1.0;
const float c = 1.0;
const float c2 = c * c;
const float PI = 3.14159265359;
const int MAX_GEODESIC_STEPS = 500;
const float GEODESIC_STEP_SIZE = 0.01;

struct KerrMetric {
    float rho2, delta, sigma;
    mat4 g_inv; // inverse metric tensor
};

float schwarzschildRadius(float mass) {
    return (2.0 * G * mass) / c2;
}

KerrMetric calculateKerrMetric(vec3 pos, vec3 bhPos, float mass, float spin) {
    vec3 relPos = pos - bhPos;

    // Convert to Boyer-Lindquist coordinates
    float r = length(relPos);
    float rs = schwarzschildRadius(mass);
    float a = spin * rs * 0.5;

    // Calculate metric components
    float cosTheta = relPos.y / r;
    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);

    KerrMetric metric;
    metric.rho2 = r * r + a * a * cosTheta * cosTheta;
    metric.delta = r * r - rs * r + a * a;
    metric.sigma = (r * r + a * a) * (r * r + a * a) - a * a * metric.delta * sinTheta * sinTheta;

    // Simplified inverse metric (key components for light deflection)
    metric.g_inv = mat4(0.0);
    metric.g_inv[0][0] = -metric.delta / metric.rho2; // g^tt
    metric.g_inv[1][1] = 1.0 / metric.rho2; // g^rr
    metric.g_inv[2][2] = 1.0 / metric.rho2; // g^θθ
    metric.g_inv[3][3] = 1.0 / (metric.rho2 * sinTheta * sinTheta); // g^φφ

    return metric;
}

// ray deflection using Kerr geodesics
vec2 calculateKerrDeflection(vec3 startPos, vec3 rayDir, vec3 bhPos, float mass, float spin, vec3 spinAxis) {
    vec3 currentPos = startPos;
    vec3 currentDir = normalize(rayDir);

    float rs = schwarzschildRadius(mass);
    float a = spin * rs * 0.5;

    vec3 relPos = currentPos - bhPos;
    float r = length(relPos);

    // If too close to black hole, return who knows what
    if (r < rs * 1.5) {
        return vec2(PI, PI); // maybe?
    }

    vec2 totalDeflection = vec2(0.0);
    float stepSize = GEODESIC_STEP_SIZE;

    // Integrate geodesic equation
    for (int step = 0; step < MAX_GEODESIC_STEPS; step++) {
        relPos = currentPos - bhPos;
        r = length(relPos);

        // Stop if we're far enough away
        if (r > rs * 50.0) break;

        // Calculate metric at current position
        KerrMetric metric = calculateKerrMetric(currentPos, bhPos, mass, spin);

        // Simplified geodesic deflection calculation
        vec3 acceleration = vec3(0.0);

        // Gravitational deflection (simplified Kerr approximation)
        float gravStrength = rs / (r * r);
        vec3 gravDir = -normalize(relPos);
        acceleration += gravStrength * gravDir;

        // Frame-dragging effect (spin contribution)
        vec3 spinCross = cross(spinAxis, relPos);
        float frameStrength = (a * rs) / (r * r * r);
        acceleration += frameStrength * normalize(spinCross);

        // Update ray direction
        vec3 newDir = currentDir + acceleration * stepSize;
        vec2 dirChange = vec2(
            atan(newDir.y, length(newDir.xz)) - atan(currentDir.y, length(currentDir.xz)),
            atan(newDir.z, newDir.x) - atan(currentDir.z, currentDir.x)
        );

        totalDeflection += dirChange;
        currentDir = normalize(newDir);
        currentPos += currentDir * stepSize;
    }

    return totalDeflection;
}

void main() {
    ivec3 coord = ivec3(gl_GlobalInvocationID.xyz);
    ivec3 lutSize = imageSize(kerrLookupTable);

    if (coord.x >= lutSize.x || coord.y >= lutSize.y || coord.z >= lutSize.z) {
        return;
    }

    // Convert 3D coordinate to spherical position around black hole
    vec3 normalizedCoord = vec3(coord) / vec3(lutSize - 1);

    // Distance from black hole (logarithmic distribution for better sampling)
    float minDist = schwarzschildRadius(u_blackHoleMass) * 2.0;
    float maxDist = u_maxDistance;
    float distance = minDist * pow(maxDist / minDist, normalizedCoord.x);

    // Spherical angles
    float theta = normalizedCoord.y * PI; // polar angle
    float phi = normalizedCoord.z * 2.0 * PI; // azimuthal angle

    // Convert to Cartesian position
    vec3 sphericalPos = vec3(
        distance * sin(theta) * cos(phi),
        distance * cos(theta),
        distance * sin(theta) * sin(phi)
    );
    vec3 worldPos = u_blackHolePos + sphericalPos;

    vec3 rayDir = normalize(sphericalPos);
    vec2 deflection = calculateKerrDeflection(worldPos, rayDir, u_blackHolePos,
                                            u_blackHoleMass, u_blackHoleSpin, u_blackHoleSpinAxis);

    // R,G = deflection angles, B = distance factor, A = validity flag
    float validityFlag = (length(deflection) < PI) ? 1.0 : 0.0;
    vec4 lutData = vec4(deflection.x, deflection.y, distance / maxDist, validityFlag);

    imageStore(kerrLookupTable, coord, lutData);
}
